\chapter{Quarta consegna}

\section{Classificare le misconceptions}

Nella seguente tabella vengono riportate alcune
misconception con il relativo tipo di difficoltà:

\begin{itemize}
    \item [$\Rightarrow$] \fancyglitter{sintattica}: relativa allo specifico
    linguaggio di programmazione che si sceglie di utilizzare (es. la dichiarazione di una variabile);
    \item [$\Rightarrow$] \newfancyglitter{concettuale}: relativa a un particolare concetto
    ricorrente nella programmazione (es. i cicli for);
    \item [$\Rightarrow$] \evidence{strategica}: relativa all'applicare i concetti appresi 
    (es. dubbi sull'utilizzare una certa struttura rispetto a un'altra).
\end{itemize}

\begin{center}
    \begin{tabular}{ || p{10.5cm} | p{5.5cm} ||}
    \hline\hline

    \textbf{\textcolor{blue}{Misconception}} & \textbf{\textcolor{blue}{Tipo di difficoltà}} \\ \hline
        
        L'assegnamento di variabili funziona in entrambe le direzioni o in direzione inversa. & Concettuale. \\\hline
        
        I tipi primitivi, in Java, hanno dei valori di default. & Sintattica. \\\hline
    
        Una condizione falsa termina un "IF" se non c'è un "ELSE". & Concettuale. \\\hline
    
        Un metodo può essere invocato solo una volta. & Strategica. \\\hline

        Una funzione cambia sempre i parametri in input per farli diventare output. & Strategica. \\\hline

        Confusione tra una classe e una sua istanza. & Concettuale. \\\hline

        Per ogni oggetto si alloca sempre la stessa quantità di memoria a prescindere dall'istanza. & Concettuale. \\\hline

        Nella ricorsione si comprende solo l'aspetto attivo, ma non i valori di ritorno
        (o viceversa). & Concettuale. \\\hline

        Si può definire un metodo, in Java, che aggiunge attributi a una classe. & Sintattica. \\\hline

        I metodi possono fare solo assegnamenti. & Concettuale. \\\hline

        Un oggetto è soltanto un record. & Concettuale. \\\hline

        Difficoltà con array a più dimensioni. & Strategica. \\\hline

        Si confondono tipi statici e dinamici. & Concettuale. \\\hline

        Confusione tra un array e una sua cella. & Concettuale. \\\hline

        I numeri sono solo numeri (int, float, etc.) & Concettuale. \\\hline

        In Java, i tipi possono cambiare "on the fly". & Sintattica. \\\hline

        Difficoltà nel comprendere il costruttore vuoto. & Sintattica. \\\hline

        Due oggetti con lo stesso nome sono lo stesso oggetto. & Concettuale. \\\hline

        Non si possono avere più metodi con lo stesso nome in file diversi. & Concettuale. \\\hline

        Salvare in memoria un oggetto vuol dire memorizzare i parametri del costruttore al momento della
        sua inizializzazione (questi parametri definiscono l'oggetto in modo non ambiguo). & Concettuale. \\\hline

    \hline
    \end{tabular}
\end{center}

\section{Misconception comuni}

In questa sezione ci occuperemo di discutere possibili soluzioni ad alcune delle misconceptions 
che abbiamo incontrato durante il nostro percorso scolastico/accademico. 

\begin{center}
    \begin{longtable}{ || p{7.8cm} | p{8.2cm} ||}
    \hline\hline
    \textbf{\textcolor{orange}{Misconception}} & \textbf{\textcolor{orange}{Analisi e Risoluzione}} \\ \hline

    L'assegnamento di variabili funziona in entrambe le direzioni. & Questa misconception
    nasce dall'utilizzo del segno uguale (=) che, generalmente, viene associato alle equazioni e quindi
    funziona in entrambi i versi. Per risolverlo si può sostituire nello pseudocodice il
    simbolo di ugualianza con simboli analoghi (:= o $\rightarrow$) ma meno equivochi, 
    tuttavia quando si passerà al codice vero e proprio bisognerà rinunciare a questo 
    \evidence{scaffolding}\footnote{Lo scaffolding è un processo di supporto che aiuta gli studenti 
    a ridurre il carico cognitivo.} . \\\hline
    
    Un metodo può essere invocato solo una volta. & Questa visione dei metodi come "usa e getta"
    è relativamente facile da correggere in quanto basta far riflettere lo studente sul perchè 
    si scelga di utilizzare un metodo invece che scrivere tutto il codice all'interno del main. \\\hline

    Per ogni oggetto si alloca sempre la stessa quantità di memoria a prescindere dall'istanza. & 
    Questa misconception compare soprattutto in linguaggi che presentano un Garbage Collector (es. Java), per cui 
    non si deve allocare e deallocare a mano la quantità di memoria che si vuole utilizzare (es. C). 
    Per risolvere si può fare un semplice esempio: se si deve scegliere uno zaino e si sa che
    devono starci poche cose è inutile prenderne uno troppo grande (spreco di spazio/memoria)
    ma, viceversa se si devono mettere dentro molte cose uno troppo piccolo non è sufficiente.\\\hline

    I numeri sono solo numeri (int, float, etc.) & Quando si scrive un equazione o una disequzione
    su carta non ci si preoccupa troppo del tipo che essi devono avere perchè gli interi possono
    essere scritti come numeri decimali con infiniti zeri, ma i computer hanno una quantità di memoria finita
    per cui una cosa del genere è infattibile. Questo "salto cognitivo" degli studenti è anche dovuto
    al processo di \evidence{cast}\footnote{Il cast è l'operazione con cui si converte una variabile da un tipo di dato a un altro.}.
    Sebbene sia utile (soprattutto nella programmazione a oggetti) può causare confusione per via 
    della fluidità con cui si passa da un int a un float. Per risolvere il problema è 
    utile spiegare agli allievi come i dati vengono effettivamente memorizzati dal calcolatore.\\\hline

    Difficoltà con array a più dimensioni. & Un array a più dimensioni può essere complicato da concettualizzare.
    Una soluzione è quella di concentrarsi sulla rappresentazione a due dimensioni: per spiegarla basta disegnare
    una tabella e mostrare che a ogni coppia di coordinate corrisponde uno e un solo valore. Da qui si deriva che lo stesso 
    vale per array a n dimensioni in cui si sostituisce il termine "coppia" con "n-upla".\\\hline

    Il nome, in linguaggio naturale, delle variabili influenza il modo in cui verranno usate nel codice e il tipo di valori. & Questa misconception è delicata da trattare:
    il nome non ha un collegamento diretto con l'utilizzo della variabile (un classico esempio è: posso chiamare una variabile Pippo, Pluto o Paperino), ma bisogna anche
    porre l'accento sul fatto che si dovrebbero utilizzare dei \evidence{nomi significativi} (un contatore lo si chiama count) in modo da rendere più semplice
    la comprensione e la lettura del codice. \\\hline

    Dopo un "IF" sia la clausola "THEN" che la clausola "ELSE" sono eseguite. & Il fraintendimento nasce da una concezione sbagliata di "IF",
    la soluzione più efficace è portare lo studente a riflettere sul perchè sia necessaria una condizione booleana.  \\\hline

    Difficoltà nel capire l'incremento del contatore in un ciclo "FOR". & La sintassi del ciclo "FOR" può
    apparire confusionaria all'inizio e il modo più semplice per affrontarla è quello di spezzarla in tre parti distinte:
    \begin{itemize}
        \item assegnamento del valore iniziale al contatore, viene eseguita solo all'ingresso nel ciclo;
        \item condizione booleana: come un "IF" che si ripete a ogni iterazione del ciclo;
        \item incremento del contatore: viene eseguito in ogni iterazione successiva alla prima.
    \end{itemize} \\\hline

    Nessun modello di ricorsione. & Per cambiare la percezione sull'impossibilità di risolvere un programma in modo ricorsivo è 
    utile illustrare un problema dove l'utilizzo della ricorsione è "naturale", per esempio la \evidence{successione di Fibonacci}.  \\\hline

    Due oggetti con lo stesso valore in un campo "nome" sono lo stesso oggetto. & Si può affrontare questo
    equivoco con un esempio: ci sono più persone che hanno lo stesso nome o lo stesso cognome, ma sono individui distinti. Così come 
    due oggetti che hanno un campo "nome" uguale non sono lo stesso oggetto: "nome" è solo una convenzione che si è scelta
    per rappresentare una caratteristica di un oggetto ma, come si è visto nella misconception sul linguaggio naturale,
    non presenta alcun legame intrinseco con l'idea che si ha di "\evidence{identità}". \\\hline

    Un costruttore può includere solo assegnamenti per inizializzare gli attributi. & L'incomprensione del concetto di costruttore
    deriva dal fatto che \textit{solitamente} si utilizza in questo modo, ma nulla vieta di effettuare altre operazioni al suo interno.
    Il modo con cui si cura questa misconception è mostrare un esempio in cui nel costruttore vengano eseguite operazioni diverse dall'assegnamento. \\\hline

    Un oggetto non può essere il valore di un attributo. & Basta semplicemente fare un esempio in cui si ha questa necessità:
    un oggetto "banca" può avere un attributo "conto" che è a sua volta un oggetto con attributi "numero", "saldo", etc... \\\hline

    Confusione di stringhe che presentano numberi con numeri veri e propri. & La sbagliata concezione dell stringhe "numeriche" come numeri
    deriva dal fatto che, nella vita quotidiana, ogni numero è di per sè una stringa (ogni simbolo può essere visto come un carattere, di fatto non c'è distinzione tra
    1 e un "1") ma allo stesso tempo un numero (ci si possono effetture dei calcoli). Come per altri problemi simili
    la soluzione risiede nell'insegnare come un computer rappresenta e veda tutto ciò. \\\hline

    \hline
\end{longtable}
\end{center}