\chapter{Quinta consegna}

\section{PRIMM}

\dfn{PRIMM}{
    PRIMM è un framework per la progettazione di attività didattiche
    per l'insegnamento della programmazione comprendente le seguenti fasi:
    \begin{itemize}
        \item \textbf{Predizione (Prediction):} gli studenti devono prevedere il
        comportamento di un programma;
        \item \textbf{Esecuzione (Run):} gli studenti devono eseguire il programma
        e verificare la predizione;
        \item \textbf{Investigazione (Investigation):} gli studenti devono correggere la
        predizione in caso di errore;
        \item \textbf{Modifica (Modify):} gli studenti devono modificare il programma
        in modo che si comporti in un modo diverso;
        \item \textbf{Risoluzione (Make):} gli studenti devono risolvere un problema
        usando il programma.
    \end{itemize}

}

\paragraph{\textcolor{blue}{Pro:}}

\begin{itemize}
    \item [$\Rightarrow$] L'esecuzione del codice, passo per passo, favorisce una chiara comprensione di ogni parte dello stesso;
    \item [$\Rightarrow$] Fornisce allo studente un riscontro immediato nella fase di esecuzione;
    \item [$\Rightarrow$] È molto \evidence{flessibile} in quanto non sempre sono necessarie tutte le fasi e si presta a modifiche a seconda del contesto.
\end{itemize}

\paragraph{\textcolor{red}{Contro:}}

\begin{itemize}
    \item [$\Rightarrow$] Non è applicabile a codici molto complessi e lunghi;
    \item [$\Rightarrow$] Nella sue fasi iniziali si fa uso di codice non appartenente allo studente che quindi può risultare difficile da capire.
\end{itemize}

\section{POGIL}

\dfn{POGIL}{
    POGIL è un framework per la progettazione di attività didattiche
    per l'insegnamento della programmazione. Durante queste attività gli
    studenti attraversano un ciclo di esplorazione, concettualizzazione e
    applicazione.
    Gli studenti scoprono i concetti chiave e costruiscono la propria
    conoscenza attraverso l'interazione con i compagni e con il docente.
}

\paragraph{\textcolor{blue}{Pro:}}

\begin{itemize}
    \item [$\Rightarrow$] Si ha uno scambio attivo di idee;
    \item [$\Rightarrow$] Ci si concentra sulla formazione di un pensiero critico;
    \item [$\Rightarrow$] L'insegnante ha il ruolo di "\evidence{facilitatore}", non viene visto come fonte di informazioni;
    \item [$\Rightarrow$] L'obiettivo è quello di insegnare a imparare e applicare la conoscenza in nuovi contesti;
    \item [$\Rightarrow$] Si vuole sviluppare la \evidence{metacognizione}, vista come la riflessione sul proprio io e sul processo stesso di apprendimento (di fatto si impara a imparare).
\end{itemize}

\paragraph{\textcolor{red}{Contro:}}

\begin{itemize}
    \item [$\Rightarrow$] Non può essere applicato efficaciemente in contesti per cui si richiede uso di specifiche nozioni non derivabili dal ragionamento (perché frutto di convenzioni);
    \item [$\Rightarrow$] Alcuni studenti potrebbero avere difficoltà a lavorare in gruppo e forzarli sarebbe solo controproducente;
    \item [$\Rightarrow$] Il fatto che gli studenti siano divisi in piccoli gruppi può limitare la circolazione di idee e di conseguenza l'apprendimento. Ciò è parzialmente risolto dalla presenza del docente, ma si ha comunque la possibilità di errore umano per cui alcuni gruppi riceveranno più attenzioni rispetto ad altri;
    \item [$\Rightarrow$] Passando a problemi più pratici, un approccio POGIL richiede tempo, materiali e risorse per essere viabile.
\end{itemize}

\section{NLD}

\dfn{NDL}{
    NLD (Necessity learning design) è un framework per la progettazione di attività didattiche
    per l'insegnamento della programmazione. Sostanzialmente si dà un problema
    risolvibile con un certo costrutto senza introdurlo. Successivamente,
    prima che lo studente si scoraggi, si introduce il costrutto. Si distinguono tre fasi:
    \begin{itemize}
        \item P!S: si dà il problema senza fornire il costrutto non necessario per risolvere l'esercizio;
        \item I: si introduce il concetto che serve;
        \item PS: gli studenti applicano il concetto appreso.
    \end{itemize}
}

\nt{La fase I è da svolgersi, preferibilmente \evidence{unplugged}, perché gli studenti, tentando di applicare subito il concetto appreso
(senza aspettare la fase PS) potrebbero perdersi dei passaggi fondamentali.}

\paragraph{\textcolor{blue}{Pro:}}

\begin{itemize}
    \item [$\Rightarrow$] È utile quando si devono apprendere concetti a un \evidence{differente livello di astrazione} (es. imparare le strutture dati conoscendo già le variabili);
    \item [$\Rightarrow$] È utilizzabile per un insegnamento mirato di un singolo concetto.
\end{itemize}

\paragraph{\textcolor{red}{Contro:}}

\begin{itemize}
    \item [$\Rightarrow$] Non è applicabile in ogni fase dell'apprendimento;
    \item [$\Rightarrow$] Necessità di un'adeguata calibrazione per evitare la perdità di interesse da parte degli studenti;
    \item [$\Rightarrow$] Alcuni studenti potrebbero sentirsi subito scoraggiati e annoiarsi invece di tentare di risolvere il problema. 
    L'idea parte dal presupposto che lo studente abbia effettivamente il desiderio di risolvere il problema, ma non è sempre così;
    \item [$\Rightarrow$] Non si può abusare di questo approccio perché gli studenti comprenderebbero l'inutilità di impegnarsi nella fase P!S che quasi sicuramente è al di fuori della loro portata. 
\end{itemize}

\section{Riflessioni sugli approcci}

Dopo aver stilato e visionato i \textcolor{blue}{pro} e i \textcolor{red}{contro} di ogni 
approccio è evidente che \textit{\textcolor{gray}{NLD}} viene percepito da noi in luce prevalentemente negativa (inoltre lo
riteniamo il meno innovativo tra i tre in quanto è un estensione di productive failure), mentre gli altri
due approcci presentano un equilibrio. Tra PRIMM e POGIL quello che preferiremmo sperimentare è il primo, per via 
della sua già citata flessibilità e della sua facile implementazione. \newfancyglitter{PRIMM} mette il focus
sul capire come funziona ogni riga di codice come una sorta di "\evidence{Divide et Impera}" e offre agli studenti
un "output" sulla loro comprensione dei meccanismi della programmazione. È ottimo per introdurre nuovi concetti,
ma allo stesso tempo fornisce allo studente la possibilità di sperimentare personalmente (fase 4 e, soprattutto, fase 5).
Riteniamo \textit{\textcolor{orange}{POGIL}} un buon approccio in linea teorica: purtroppo la metacognizione è un concetto
molto poco esplorato nell'ambito dell'istruzione, almeno in Italia. Però questo approccio necessità di apposita formazione e 
materiale didattico specifico (per guidare gli studenti), il ché può diventare dispendioso. Inoltre non ha quell'adattabilità
a molteplici concetti che abbiamo trovato in PRIMM.