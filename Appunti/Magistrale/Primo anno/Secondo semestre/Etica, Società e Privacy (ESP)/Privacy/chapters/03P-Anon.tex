\chapter{Framework di Anonimizzazione}

\nt{Molti di questi Framework sono superati, ai giorni nostri \fancyglitter{differential privacy} ha soppiantato tutti gli altri.}

\section{Il Problema dell'Anonimità}

\paragraph{Problema:}

\begin{itemize}
  \item Molte agenzie, istituzioni, organizzazioni, etc. rendono pubblicamente disponibili dati sensibili riguardanti persone: 
    \begin{itemize}
      \item Molti microdata per le analisi. 
      \item Spesso la legge richiede la loro anonimizzazione.
    \end{itemize}
  \item I microdata vengono \fancyglitter{sanificati} (rimossi gli id espliciti). 
  \item Non è sufficiente per preservare la privacy:
    \begin{itemize}
      \item Suscettibili a \fancyglitter{linking attack}. 
      \item Databases pubblici possono rilevare identità "segrete".
    \end{itemize}
\end{itemize}

\subsection{Linking Attack}

Nel 2001, Latanya Sweeney riuscì a reidentificare i record medico del governatore del Massachussetts: 
\begin{itemize}
  \item Il Massachussetts colleziona e pubblica dati medici sanificati per gli impiegati statali. 
  \item I dati dei votanti registrati sono pubblicamente disponibili.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.41]{03P/LA.png}
    \caption{Linking Attack del 2001.}
\end{figure}

\paragraph{Ruoli degli attributi nei microdata:}

\begin{itemize}
  \item Identificatori espliciti: sono rimossi. 
  \item Quasi identificatori: possono essere usati per reidentificare individui. 
  \item Attributi sensibili: portano informazioni sensibili.
\end{itemize}

\nt{Il goal della preservazione della privacy è quello di \fancyglitter{deassociare} individui da informazioni sensibili.}

\dfn{Quasi Identificatori (Tore Dalenius, 1986)}{
  I quasi identificatori sono attributi che non sono univoci di per sé, ma che se combinati con altri quasi identificatori possono creare un identificatore univoco. 
}

\paragraph{I quasi identificatori sono facilmente attaccabili:}

\begin{itemize}
  \item Linking attack di Sweeney. 
  \item Arvind Narayanan e Vitaly Shmatikov hanno usato i quasi identificatori per deanonimizzare dati di Netflix.
\end{itemize}

\section{K-Anonimity}

\dfn{Quasi Identificatori}{
  Assumiamo $A = {a_1,\dots,a_n}$ come insieme di $n$ attributi e $D$ un dataset definito su $A$. Un quasi identificatore di $D$ è un sottoinsieme di attributi $QI \subseteq S$ che deve essere controllato prima della pubblicazione.
}


\nt{Per risolvere il problema Sweeney e Samarati proposero, nel 1998, la \fancyglitter{k-anonimity}.}

\dfn{K-Anonimity}{
  Assumiamo $T$ come dataset su un insieme $A={a_1,\dots,a_n}$ di attributi e $QI_T$ come insieme di quasi identificatori di $T$. $T$ \textit{soddisfa} la k-anonimity se e solo se per ogni quasi identificatore $QI \in QI_T$ ogni sequenza esistente di valori attribuiti a $QI$ compare almeno con $k$ occorrenze in $T$.
}

\clm{}{}{
  Ogni pubblicazione dei dati deve essere controllata in modo che la combinazione dei valori dei quasi identificatori può essere associata ad almeno $k$ tuple:
\begin{itemize}
  \item Si nasconde ogni individuo in $k-1$ altri individui. 
  \item I linking attack non possono essere effettuati con una confidenza superiore a $\frac{1}{k}$.
\end{itemize}

}

\paragraph{Condizioni sufficienti per la k-anonimity:}

\begin{itemize}
  \item Ogni insieme di valori associati a un quasi identificatore deve avere almeno $k$ occorrenze. 
  \item Gli attributi sensibili non sono considerati.
\end{itemize}

\subsection{Come Ottenere la K-Anonimity?}

Esistono diversi modi per ottenere la k-anonimity:

\begin{itemize}
  \item \fancyglitter{Generalizzazione:} il valore di un dato attributo è rimpiazzato da uno più generale. 
    \begin{itemize}
      \item Negli ZIP code si nascondono le ultime due cifre $(10149 \rightarrow 101**, 10126 \rightarrow 101**)$. 
      \item La data di nascita rimpiazzata dall'anno di nascita $(27/09/1964 \rightarrow 1964, 30/09/1964 \rightarrow 1964)$.
    \end{itemize}
  \item \fancyglitter{Soppressione:} proteggere informazioni sensibili rimuovendole.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.41]{03P/kanon.png}
    \caption{Esempio di applicazione di k-anonimity.}
\end{figure}

\paragraph{Privacy vs. Utility:}

\begin{itemize}
  \item Se i dati vengono troppo anonimizzati diventano inutili. 
  \item Per cui non si deve anonimizzare più del necessario.
\end{itemize}

\dfn{Domain Generalization Hierarchy}{
  Una gerarchia di generalizzazione su un dominio $(DGH_D)$ di un attributo $A$ è un ordine parziale su un insieme di domini $Dom_A = {D_0,\dots,D_n}$ che soddisfa le seguenti condizioni:
  \begin{itemize}
    \item Ogni dominio $D_i$ ha al più una generalizzazione diretta. 
    \item Tutti gli elementi massimi di $Dom$ sono singletons (per far sì che tutti i valori in ogni dominio possano essere generalizzati in un singolo valore).
  \end{itemize}
}

\clm{}{}{
Esempio: 
\begin{itemize}
  \item Z0: 53715, 53710, 53706, 53703. 
  \item Z1: 5371*, 5370*. 
  \item Z2: 537**.
\end{itemize}
}

\cor{Value Generalization Relationship}{
  Una relazione di valori generalizzati associa a ogni valore $v_i$ del dominio $D_i$ un valore univoco $v_j$ in un dominio $D_j$ dove $D_j$ è una diretta generalizzazione di $D_i$.
}

\nt{La relazioni implicano, per ogni dominio $D$, l'esistenza di un Value Generalization Relationship $VGH_D$. $VGH_D$ può essere rappresentato come un albero con il valore più generale come radice e i valori più specifici come foglie.}

\cor{Generalization Lattice}{
  Dato un dominio di tuple $DT = < D_{A1},\dots,D_{An}$ tale che $D_{Ai}$ sia in $Dom_{Ai}$, la gerarchia di generalizzazione del dominio di $DT$ è 

  $$DGH_{DT} = DGH_{D_{A1}} x \dots x DGH_{D_{An}}$$
 
  $DGH_{DT}$ definisce un reticolo il cui elemento minimo è $DT$.
}

\dfn{Generalized Table with Suppression}{
  Dato un insieme di attributi $A = {A_1,\dots,A_n}$ e due tabelle $T_i$ e $T_j$ definiti su $A$, la tabella $T_j$ è una generalizzazione della tabella $T_i$ ($T_i \leq T_j$) se e solo se: 
  \begin{itemize}
    \item Il dominio di ogni attributo $A_x$ in $T_j$ è uguale o una generalizzazione del dominio di $A_x$ in $T_i$. 
    \item Ogni tupla $t_j$ in $T_j$ ha una tupla $t_i$ corrispondente in $T_i$ tale che per ogni attributo $A_x$, $t_j[A_x]$ è uguale o una generalizzazione di $t_i[A_x]$.
  \end{itemize}
}

\nt{Non tutte le generalizzazioni hanno lo stesso valore.}

\cor{Vettore Distanza}{
  Date due tabelle $T_i$ e $T_j$ definite sullo stesso insieme di elementi $A = {A_1,\dots, A_n}$ tale che $T_i \leq T_j$, il vettore distanza di $T_j$ da $T_i$  è il vettore $DV_{ij} = [d_1,\dots,d_n]$ dove ogni $d_x$ è la lunghezza del percorso univoco tra $dom(A_x, T_i)$ e $dom(A_x, T_j)$ in $DGH_{DX}$.
}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.39]{03P/vd.png}
    \caption{Percorsi di generalizzazione.}
\end{figure}

\nt{L'obiettivo è  trovare la minima generalizzazione che soddisfi la k-anonimity. In questo modo si ha sia anonimizzazione che perdità di informazioni limitata (massimizzazione dell'utilità). Ciò si può fare trovando il vettore distanza minimo.}

\dfn{K-Minimal Generalization with Suppression}{
Date due tabelle $T_i$ e $T_j$ tali che $T_i \leq T_j$ e MaxSup lo specifico threshold di soppressione accettabile, $T_j$ è una generalizzazione k-minima di $T_i$ se e solo se: 
\begin{itemize}
  \item $T_j$ soddisfa la k-anonimity. 
  \item La soppressione è minimale. 
  \item $|T_j| - |T_i| \leq$ MaxSup. 
  \item $\forall T_x: T_i \leq T_x, T_x$ soddisfa gli altri tre punti $\Rightarrow DV_{ix} \geq DV_{ij}$.
\end{itemize}
}

\paragraph{Livelli di granularità delle tecniche di k-anonimity:}

\begin{itemize}
  \item Generalizzazione:
    \begin{itemize}
      \item Su singola colonna: passi di generalizzazione su tutti i valori di una colonna. 
      \item Su singola cella: per una specifica colonna. 
    \end{itemize}
  \item Soppressione: 
    \begin{itemize}
      \item Su singola riga: si sopprime tutta la tupla. 
      \item Su singola colonna: si oscurano tutti i valori di una colonna. 
      \item Su singola cella: solo alcune celle sono cancellate.
    \end{itemize}
\end{itemize}

\subsection{Algoritmi per la K-Anonimity}

Il problema di trovare le tabelle con la minima k-anonimity, con generalizzazione di attributi e soppressione di tuple, è \fancyglitter{NP-hard}. La grande maggioranza degli algoritmi proposti hanno un tempo computazionale esponenziale con il numero dei valori degli attributi (approccio greedy). Quando il numero $|QI|$ degli attributi nei quasi identificatori è piccolo rispetto al numero $n$ di tuple nelle tabelle di k-anonimity questi algoritmi sono effettivamente praticabili.

\dfn{Samarati's Algorithm}{
  Ogni percorso in $DGH_{DT}$ rappresenta una strategia di generalizzazione. L'algoritmo si basa su una generalizzazione minima locale (il nodo minore di ogni percorso che soddisfi la k-anonimity). L'algoritmo effettua una ricerca binaria sul reticolo dei vettori distanza: 
  \begin{enumerate}
    \item Valuta tutte le soluzioni ad altezza $\frac{h}{2}$. 
    \item Se esiste almeno una soluzione che soddisfi la k-anonimity:
      \begin{itemize}
        \item Valuta tutte le soluzioni ad altezza $\frac{h}{4}$. 
        \item Altrimenti valuta tutte le soluzioni ad altezza $\frac{3h}{4}$.
      \end{itemize}
    \item Ripeti fino a ché l'algoritmo non raggiunge l'altezza minore per cui esiste un vettore distanza che soddisfi la k-anonimity.
  \end{enumerate}
}

\nt{Se non c'è nessuna soluzione che garantisce la k-anonimity ssopprimendo meno di MaxSup tiple ad altezza $h$ allora non può esistere una soluzione con altezza minore a $h$ che garantisce la k-anonimity (approccio branch and bound).}

\paragraph{Altre proprietà:}
\begin{itemize}
  \item Ogni generalizzazione k-minima è localmente minima rispetto a un percorso. 
  \item Salendo nella gerarchia il numero di tuple che devono essere rimosse dalla k-anonimity decresce.
\end{itemize}

\dfn{Incognito Algorithm}{
  Adotta un approccio bottom-up per la visita di $DGHs$. La proprietà di k-anonimity
   rispetto a un sottoinsieme $QI$ è una condizione \textit{necessaria} per la k-anonimity rispetto a $QI$. 
   \begin{itemize}
    \item Iterazione 1: controlla la k-anonimity per ogni attributo in $QI$ scartando le generalizzazioni che non soddisfano la k-anonimity. 
    \item Iterazione 2: combina le rimanenti generalizzazioni in coppie e controlla la k-anonimity per tutte. 
    \item Iterazione $i$: combina tutte le $i$-uple e controlla nuovamente la k-anonimity. 
    \item Iterazione $QI$: risultato.
   \end{itemize}
}

\nt{La proprietà sfruttata dal k-anonimity è la monoticità del reticolo. In realtà l'Incognito Algorithm potrebbe andare sia dal basso verso l'alto che dall'alto verso il basso.}

\section{Oltre la K-Anonimity}

\section{Differential Privacy}


