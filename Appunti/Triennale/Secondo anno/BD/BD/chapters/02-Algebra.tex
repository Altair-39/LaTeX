\chapter{Algebra e Calcolo Relazionale}

\section{Algebra Relazionale}
L'\textcolor{blue}{algebra relazionale} manipola relazioni per ottimizzare le \textit{query}\footnote{Elenco dei passi da eseguire per rispondere a un'interrogazione}. Ogni passo è definito attraverso gli operatori algebrici: selezione, proiezione, unione, intersezione, differenza, prodotto cartesiano, ridenominazione, join, quoziente. Ogni operatore riceve in input un argomento (una relazione) e produce in output una relazione virtuale. La \textcolor{blue}{cardinalità} di una relazione virtuale è definita su un intervallo ed è il numero di tuple che la relazione contiene.

\subsection{Operatori algebrici}

\subsubsection{Selezione}

\label{Operatore di selezione}

\label{Selezione}

In una relazione r su uno schema A, $\sigma_p(r(A))$, l’operatore di \textcolor{blue}{selezione} produce come risultato:
\begin{itemize}
	\item schema: A;
	\item istanza: le tuple della relazione r che soddisfano il predicato p.
\end{itemize}

Esempio: seleziona i pazienti con la residenza a Torino

($\sigma_{residenza=Torino}$(Pazienti)).

La cardinalità della relazione virtuale dell'operatore di selezione è:

$0 \leq |\sigma_p(r(A))| \leq |r(A)|$

0 se il predicato è falso per tutte le tuple, $|r(A)|$ se il predicato è vero per tutte le tuple.

\paragraph{Proprietà:}
\begin{itemize}
	\item distributiva rispetto a proiezione, unione, intersezione, differenza, join, prodotto cartesiano;
	\item selezione multipla;
	\item sostituzione degli operatori.
\end{itemize}

\subsubsection{Proiezione}

\label{Proiezione}

In una relazione r su uno schema A, $\pi_{A_i, A_j,..., A_k}(r(A))$, l’operatore di \textcolor{blue}{proiezione} produce come risultato:
\begin{itemize}
	\item schema: \{$A_i, A_j,..., A_k$\};
	\item istanza: tutte le tuple della relazione argomento, ma solo rispetto agli attributi $A_i, A_j,..., A_k$.
\end{itemize}

Esempio: i cognomi di tutti i pazienti

($\pi_{cognome}$(Pazienti)).

La cardinalità della relazione virtuale dell'operatore di proiezione è:

$0 \leq |\pi_{A_i, A_j,..., A_k}(r(A))| \leq |r(A)|$

Se gli attributi proiettati $A_i, A_j,..., A_k$ formano una superchiave della relazione argomento allora $$|\pi_{A_i, A_j,..., A_k}(r(A))| = |r(A)|$$

\paragraph{Proprietà:}
\begin{itemize}
	\item distributiva rispetto a unione, join, prodotto cartesiano;
	\item proiezione multipla.
\end{itemize}

\subsubsection{Unione, intersezione e differenza}
\label{Op ins}
Gli \textcolor{blue}{operatori insiemistici} (unione, intersezione e differenza) richiedono che gli schemi dei loro argomenti siano uguali.
Il risultato dell’operatore insiemistico sulle relazioni argomento $r_1$(A) e $r_2$(A) è una relazione che ha:
\begin{itemize}
	\item schema: lo stesso schema A delle relazioni argomento;
	\item istanza unione: $r_1$(A) U $r_2$(A);
	\item istanza intersezione: $r_1 \cap r_2$
	\item istanza differenza: $r_1$(A) - $r_2$(A).
\end{itemize}

La cardinalità della relazione virtuale dell'operatore di unione è:

$max{|r_1(A)|,|r_2(A)|} \leq |r_1(A) U r_2(A)| \leq |r_1(A)|+|r_2(A)|$

La cardinalità della relazione virtuale dell'operatore di intersezione è:

$0 \leq |r_1(A) \cap r_2(A)| \leq min{|r_1(A)|,|r_2(A)|}$

La cardinalità della relazione virtuale dell'operatore di differenza è:

$0 \leq |r_1(A) - r_2(A)| \leq |r_1(A)|$

L'intersezione può essere ricavata dalla differenza: $r_1(A) \cap r_2(A)$ := $r_1(A) - (r_1(A) - r_2(A))$

\subsubsection{Prodotto cartesiano}

Date due relazioni $r_1$(A) e $r_2$(B) con $A \cap B = \emptyset$ (i due schemi non hanno attributi in comune), il \textcolor{blue}{prodotto cartesiano} $r_1$(A) X $r_2$(B) produce come risultato una relazione r' con:
\begin{itemize}
	\item schema: R' composto dall’unione degli schemi A U B;
	\item istanza: combinazione di tutte le tuple di $r_1$(A) con tutte le tuple di $r_2$(B).
\end{itemize}

La cardinalità della relazione virtuale dell'operatore di prodotto cartesiano è:

$0 \leq |r_1(A) X r_2(B)| \leq |r_1(A)| \cdot |r_2(B)|$

Il prodotto cartesiano non ha utilità pratica di per sè, ma viene usato per definire altri operatori.

\paragraph{Proprietà:}
\begin{itemize}
	\item associativa;
	\item commutativa.
\end{itemize}

\subsubsection[\texorpdfstring{\\}{ }Ridenominazione]{Ridenominazione}

Il compito dell'operatore di \textcolor{blue}{ridenominazione} è quello di cambiare il nome di alcuni o tutti gli attributi della relazione argomento.

$\sigma_{B_i, B_j, ...} \leftarrow  _{A_i, A_j, ...}(r)$

\begin{itemize}
	\item schema: A' = ${A_1, ..., B_i, B_j, ..., A_n}$;
	\item istanza: le tuple non vengono modificate.
\end{itemize}

\subsection{Join interni}
\label{Join i}
\subsubsection{Theta-join}

Date due relazioni $r_1$(A) e $r_2$(B) con $A \cap B = \emptyset$ (i due schemi non hanno attributi in comune) e una condizione (predicato) $\theta$ di join (tipicamente $\theta$ è una formula proposizionale con confronti tra attributi del tipo $A_i \phi B_j$ o confronti tra attributi e valori $A_i \phi$ costante dove $\phi$ è un simbolo di confronto) il $\theta$-join (\textcolor{blue}{theta-join}) è definito come una selezione in base al prodotto cartesiano:

$r_1(A) \bowtie_\theta r_2(B) := \sigma_\theta ( r_1(A) X r_2(B) )$

La cardinalità della relazione virtuale dell'operatore di theta-join è:

$0 \leq |r_1(A) \bowtie_\theta r_2(A)| \leq |r_1(A)| \cdot |r_2(B)|$

Può essere utile eseguire una proiezione per rimuovere eventuali attributi derivati in eccesso. Se si vuole fare un join su schemi non disgiunti occorre ridenominare alcuni attributi.

\paragraph{Proprietà:}
\begin{itemize}
	\item associativa ristretta;
	\item commutativa.
\end{itemize}

\subsubsection{Equi-join}

L'\textcolor{blue}{equi-join} ($\theta_e$) è un caso particolare del theta-join in cui i confronti sono solo uguaglianze.

La cardinalità della relazione virtuale dell'operatore di equi-join è:

$0 \leq |r_1(A) \bowtie_{\theta_e} r_2(A)| \leq |r_1(A)|$

\subsubsection{Natural-join}

Il \textcolor{blue}{natural-join} serve a confrontare attributi con lo stesso nome in tabelle diverse. Esso è un equi-join che è sempre vero.

\subsubsection{Semi-join}

Il \textcolor{blue}{semi-join} è un filtro sulla prima relazione usando la seconda, una proiezione che prende in considerazione gli attributi della prima relazione dopo aver fatto un join tra le due.

\subsubsection{Composizione di operatori}

L’algebra relazionale è composizionale, quindi si possono costruire espressioni complesse componendo operatori.

Esempio: $\pi_{Cod, Nome}(\sigma_{Residenza='TO' \vee Residenza='VC'}(Pazienti)$

\subsubsection{Dot notation}

La \textcolor{blue}{dot notation} serve per evitare di scrivere operazioni molto lunghe. Essa è un'operazione di ridenominazione sottintesa. Nella parte prima del punto va indicata la relazione e in quella dopo il punto va indicato l'attributo.

$\sigma_{MEDICI.Cognome,MEDICI.Nome,MEDICI.Residenza,MEDICI.Reparto} \leftarrow $

$\leftarrow_{Cognome,Nome,Residenza,Reparto}(Medici)$

\section{Interrogazioni}

\subsection{Interrogazioni con negazione}

Nelle basi di dati si assume un mondo chiuso\footnote{Closed-world assumption}. Per cui gli unici fatti veri sono quelli presenti nella base di dati. Se un fatto non è descritto allora è falso.

\paragraph{Schema generale:}
\begin{enumerate}
	\item si definisce l'universo del discorso (U);
	\item si risponde all'interrogazione in modo positivo (P);
	\item si trova la risposta all'interrogazione originale con la differenza tra U e P\footnote{U e P devono avere lo stesso schema, inoltre ciò vale solo in un mondo chiuso}.
\end{enumerate}

\subsection{Interrogazioni con quantificazione universale}

L'algebra relazionale non è in grado di gestire direttamente la quantificazione universale per cui ci deve ricondurre alla quantificazione esistenziale.

\paragraph{Schema generale:}

\begin{enumerate}
	\item si definisce l'universo del discorso (U);
	\item si ricavano tutte le combinazioni possibili;
	\item si trova la differenza;
	\item si proietta sugli attributi di interesse;
	\item si sottrae il risultato del punto 4 all'universo del punto 1.
\end{enumerate}

Questo ragionamento corrisponde all'operatore quoziente.

\subsection{Quoziente}

Il \textcolor{blue}{quoziente} è un operatore derivato: $r(A, B) \div s(B) := \pi_a(r) - \pi_a((\pi_a(r) X s) - r)$.
Serve per ricavare tutte le tuple di r che compaiono in ogni combinazione. Non è implementato in SQL per cui si devono utilizzare sotto-query.

La cardinalità della relazione virtuale dell'operatore quoziente è:

$0 \leq |r(A,B) \div s(B)| \leq |\pi_A(r)| \leq |r|$

\subsection{Join esterni}
\label{Join e}
\subsubsection{Left join}

Il \textcolor{blue}{left join} contiene tutte le tuple della relazione a sinistra in join con la relazione di destra. Nel caso una tupla della relazione destra non faccia join con nessuna tupla della relazione di sinistra si inserisce il valore NULL per gli attributi della seconda relazione.

\subsubsection{Right join}

Il \textcolor{blue}{right join} contiene tutte le tuple della relazione a destra in join con la relazione di sinistra. Nel caso una tupla della relazione sinistra non faccia join con nessuna tupla della relazione di destra si inserisce il valore NULL per gli attributi della prima relazione.

\subsubsection{Full join}

Il \textcolor{blue}{full join} è l'unione di left join e right join.

\subsection{Semantica di Codd del valore nullo}

\label{Logica a tre valori}

La \textcolor{blue}{semantica di Codd} del valore nullo è il comportamento di un'interrogazione con tuple che contengono valori nulli. Per fare ciò, Codd propose di passare da una logica a due valori (True, False) a una logica a tre valori (True, False, Unknown).

\subsubsection{Logica a tre valori}

\paragraph{Tre valori:}

\begin{itemize}
	\item True (T, vale 2);
	\item False (F, vale 0);
	\item Unknown (U, vale 1).
\end{itemize}

\paragraph{In questa logica:}

\begin{itemize}
	\item AND si calcola con il minimo;
	\item OR si calcola con il massimo;
	\item NOT si calcola con 2 - p.
\end{itemize}

Per cercare un valore nullo si usa il predicato ISNULL, per cercarne uno non nullo si usa ISNOTNULL.
In questa logica non valgono nè il principio di non contraddizione, nè il principio del terzo escluso.

\subsection{Ottimizzazione delle interrogazioni}

\textcolor{blue}{Ottimizzare} significa rendere più efficiente un'implementazione.

Poichè i DBMS sono molto grandi sono memorizzati in memoria secondaria e, quindi, se un'applicazione richiede una tupla bisogna portare in memoria la pagina in cui è memorizzata. Per ottimizzare \textcolor{blue}{il tempo} si deve minimizzare il numero di pagine da trasportare in memoria primaria (\textit{buffer}).
L'ottimizzazione si svolge in due passaggi:
\begin{itemize}
	\item Ottimizzazione logica;
	\item Ottimizzazione fisica.
\end{itemize}

\subsubsection{Ottimizzazione fisica}

L’ottimizzatore \textcolor{blue}{fisico} entra nei nodi (\textit{operatori}) dell’albero sintattico, li esamina e in base alle strutture fisiche sceglie
l’algoritmo ottimale per eseguire ogni nodo. Si vedrà più in dettaglio nella magistrale.

\subsubsection{Ottimizzazione logica}

L'ottimizzazione \textcolor{blue}{logica} prende in input l’albero sintattico dell’interrogazione e lo trasforma sfruttando le proprietà dell’algebra relazionale.

Il principio su cui si basa l'ottimizzatore logico è: ridurre il numero di tuple coinvolte dall'interrogazione, mantenendo lo stesso risultato. In quasi tutte le operazioni di un sistema informativo si lavora su poche tuple per volta, compiendo una selezione\footnote{vedi \ref{Operatore di selezione}}.

Per ottimizzare si utilizza la proprietà distributiva della selezione. I predicati p della selezione sono in forma congiuntiva (si può ricondurre qualsiasi predicato a una congiunzione di disgiunzioni):
\begin{enumerate}
	\item Si decompongono gli \textbf{AND}: $\sigma_p (r(A) \bowtie_\theta s(B))\rightarrow \sigma_p (r(A)) \bowtie_\theta s(B)$, che è valida solo se gli attributi coinvolti da p sono contenuti solo in A;
	\item Si trasferiscono le \textcolor{blue}{selezioni} verso le foglie finché è possibile con le proprietà distributive della selezione;
	\item Si traferiscono le \textcolor{blue}{proiezioni} verso le foglie finché è possibile con le proprietà distributive della proiezione;
	\item L’ottimizzatore ricompone insieme le selezioni multiple, applicando una sola selezione con una congiunzione di predicati;
	\item Si traforma la selezione + prodotto cartesiano in un $\bowtie_\theta$ (perchè è meglio nell'ottimizzazione fisica);
	\item Ricondurre a un’unica proiezione le proiezioni multiple;
	\item Si esaminano le varianti dell’albero sintattico dovute alle proprietà associative scegliendo la variante di costo minimo.
\end{enumerate}

\subsubsection{Aspetti quantitativi nelle interrogazioni}
I DBMS hanno un dizionario di dati in cui vengono memorizzare varie informazioni:
\begin{itemize}
	\item \textbf{CARD(r) = $|r|$} : è la cardinalità della relazione;
	\item \textbf{SIZE(t)} : ampiezza della tupla in byte;
	\item \textbf{VAL($A_i$,r)} : numero di valori distinti che appaiono nella colonna $A_i$ all'interno della tabella r;
	\item \textbf{MIN($A_i$,r)} : il valore minimo di $A_i$ contenuto in r;
	\item \textbf{MAX($A_i$,r)} : il valore massimo di $A_i$ contenuto in r;
	\item \textbf{NPAGE(r)} : il numero di pagine occupate da r.

	      $\textbf{NPAGE(r)} = \frac{\textbf{CARD(r)}}{\textit{fattore di bloccaggio}}$. Il \textit{fattore di bloccaggio} è il numero massimo di tuple contenute in una pagina.
\end{itemize}

\subsection{Analisi dei costi delle interrogazioni}

L'analisi quantitativa dell'interrogazione permette di predire a priori il risultato della cardinalità della relazione, senza eseguirla.

\subsubsection{Stima del costo della selezione}

Data la selezione $\sigma_p (r)$, conoscendo l’intervallo di variabilità della selezione $\sigma_p (r)$:
$0 \leq |\sigma_p (r)| \leq |r|$, si può modellare la cardinalità della selezione $\sigma_p (r)$ con un \textcolor{blue}{\textit{fattore di selettività}} $f_p$ per la cardinalità di r $|\sigma_p (r)| = f_p X |r|$.
Il fattore di selettività $f_p$ è legato al solo predicato p di selezione e varia tra 0 e 1.

Il fattore di selettività $f_p$ può essere interpretato come la probabilità che una tupla in r soddisfi il predicato di selezione p, ovvero la stima della percentuale di tuple che soddisfano il predicato di selezione. Per stimare $f_p$ si assumono una \textit{distribuzione uniforme} e \textit{un'assenza di correlazione} tra attributi diversi.

\subsubsection{Stima della cardinalità del join}


Per stimare $|r(A)\bowtie_{A_i = B_j} s(B)|$, consideriamo prima una singola tupla
$t' \in r$ per cui $t'[A_i]=v$ (v è una costante):
\begin{itemize}
	\item la probabilità che una singola tupla $t'' \in s$ sia tale che $t''[B_j]=v$ è $\frac{1}{\textbf{VAL}(B_j, s)}$;
	\item considerando tutta la relazione s, ci saranno $\frac{1}{\textbf{VAL}(B_j, s)}$ × \textbf{CARD(s)} tuple t'' per cui t''$[B_j]=v$.
\end{itemize}

Se non esiste un vincolo di integrità referenziale, sappiamo che la stima precedente è ottimistica, perché potrebbe non esserci nessuna tupla in s tale che t''$[B_j]=v$.

Si possono fare due stime, entrambe ottimistiche, quindi si deve prendere quella minore: $|r(A) \bowtie_{A_i=B_j} s(B)|$ = min \{$\frac{1}{\textbf{VAL}(A_i, r)}$ , $\frac{1}{\textbf{VAL}(B_j, r)}$ \} × \textbf{CARD}(r) × \textbf{CARD}(s).

\section{Calcolo Relazionale su Tuple con Dichiarazione di Range}

Il \textcolor{blue}{Calcolo relazionale sulle tuple con dichiarazione di range} è la base teorica di SQL. In questo calcolo le variabili denotano tuple e bisogna specificare un \textit{range} di valori possibili. Le sue interrogazioni sono composte da tre parti:

$\\$
$\{T|L|F|\}$

\begin{itemize}
	\item \textit{Target (T)}: specifica gli attributi che compaiono nel risultato;
	\item \textit{Range list (L)}: specifica il dominio delle variabili non quantificate in F;
	\item \textit{Formula (F)}: specifica un'espressione logica che deve essere soddisfatta dal risultato.
\end{itemize}

Il risultato è dato da:
\begin{itemize}
	\item l’insieme dei valori degli attributi T;
	\item presi dalle tuple nelle variabili in L;
	\item che rispettano la formula in F.
\end{itemize}

\subsection{Target e Range List}

\subsubsection{Target list}

La \textcolor{blue}{target list} è l’elenco delle informazioni che si vogliono avere in uscita. Le variabili usate nella target list devono essere dichiarate nella Range list. Ci sono diverse sintassi possibili:
\begin{itemize}
	\item variabile.Attributo1, variabile.attributo2,...;
	\item variabile.(Attributo1,Attributo2,...);
	\item variabile.*\footnote{Restituisce tutti gli attributi};
	\item Nome: variabile.attributo.
\end{itemize}

Esempio: p.Nome, p.Cognome significa che nel risultato compariranno nomi e cognomi.

\subsubsection{Range list}

La \textcolor{blue}{range list} è l'introduzione di variabili abbinate a relazioni di base.

nome\_variabile(nome\_relazione\_di\_base)
$\\$
Esempio: p(Pazienti) significa che la variabile p assume valori nella relazione Pazienti. Ed è una qualunque tupla di pazienti.

\subsection{Logica}

\subsubsection{Formula}

La \textcolor{blue}{formula} è un predicato di logica del primo ordine che vincola le variabili della range list. Quindi si possono applicare i soliti operatori della logica proposizionale (AND, OR, NOT, etc.) e i quantificatori esitenziali e universali.

Esempio: p.Residenza='TO' significa che, data una tupla p, perché questa faccia parte del risultato, l’attributo Residenza di p deve valere ‘TO’.

La formula è un predicato del primo ordine che può contenere sia variabili libere che quantificate (vincolate).
Tutte le variabili libere presenti nella formula devono essere dichiarate nella range list.

$\exists$variabile(Relazione)(formula)

$\forall$variabile(Relazione)(formula)

\subsubsection{Limitazioni}

Nel calcolo relazionale sulle tuple con dichiarazione di range non è possibile esprimere l'unione. Infatti nella range list ogni variabile ha come dominio una sola relazione, mentre l’unione richiede che il risultato venga da una relazione o da un’altra. SQL (che è basato su questo calcolo) prevede un operatore esplicito di unione, ma non tutte le versioni prevedono intersezione e differenza.
Inoltre manca il concetto di ricorsione, per cui non è possibile esprimere alcune query.
Esempio: discendente(Persona1,Persona2) esprime tutte le discendenze e richiederebbe una chiusura transitiva\footnote{Le chiusure transitive sono implementate nelle ultime versioni di SQL}.

\subsubsection{Calcolo relazionale e SQL}

Il calcolo relazionale è direttamente correlato alla sintassi di SQL.

\begin{itemize}
	\item La target list corrisponde alla SELECT;
	\item La range list corrisponde alla FROM;
	\item La formula corrisponde alla WHERE.
\end{itemize}

Tuttavia in SQL non è presente il quantificatore universale per cui si ricorre al NOT e al quantificatore esistenziale.

