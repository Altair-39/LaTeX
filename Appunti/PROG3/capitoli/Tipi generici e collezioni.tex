\chapter{Tipi generici e collezioni}

Si vuole poter lavorare in modo "safe" con i tipi di dati senza dover costantemente controllare i tipi di dato.

\section{Tipi generici}

\dfn{Tipi generici}{
I tipi generici si usano per scrivere codice generico applicabile a più tipi di dati (riusabilità del codice). Il tipo E fa un match con qualunque tipo di dato non primitivo al momento della compilazione.

I generici sono stati introdotti per fare inferenza in fase di type checking statico.
}

\nt{Solitamente per i tipi generici si usa la lettera E, ma è solo una convenzione. Qualunque lettera va bene.}

\nt{Si potrebbe usare il tipo Object, ma ciò ha delle limitazioni: per esempio, in un array, possono essere inseriti elementi di tipi diversi. Ovviamente si può usare la reflection, ma ciò è scomodo e inefficiente.}

\ex{ArrayList}{
La classe ArrayList è generica, per cui può contenere oggetti di qualunque tipo. Tuttavia se non si specifica il tipo (ArrayList a = new ArrayList();) verrà considerato Object causando i problemi visti sopra.
}

\dfn{Tipi parametrici}{
Un tipo parametrico è una classe in cui è specificato il tipo generico da inferire.
}

\ex{ArrayList parametrico}{ArrayList$<$Double$>$ a = new ArrayList$<$Double$>$;}

\nt{Si possono creare classi generiche mettendo il parametro E nel nome della classe ($<$E$>$).}

\dfn{Tipo grezzo}{Il compilatore non ragiona in termini di tipi generici. Quindi il compilatore li trasforma in tipi grezzi (raw types), ossia unicamente il tipo della classe senza i parametri.}

\ex{ArrayList}{Quindi: 

ArrayList$<$String$>$ a = new ArrayList$<$String$>$

ArrayList$<$Double$>$ a = new ArrayList$<$Double$>$

hanno lo stesso tipo ArrayList.
}

\nt{Non si possono avere metodi statici con tipi generici all'interno delle classi che usano quei tipi.}











